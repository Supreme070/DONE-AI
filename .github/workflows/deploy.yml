name: Deploy Application

on:
  push:
    branches:
      - main      # Deploy to production
      - develop   # Deploy to staging
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy (leave empty for latest)'
        required: false
        type: string

env:
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME_PREFIX: ${{ github.repository_owner }}/omnisecai

jobs:
  determine-environment:
    name: Determine Deployment Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should_deploy: ${{ steps.env.outputs.should_deploy }}
    steps:
      - name: Determine environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  pre-deployment-checks:
    name: Pre-deployment Security Checks
    runs-on: ubuntu-latest
    needs: [determine-environment]
    if: needs.determine-environment.outputs.should_deploy == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run security scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'table'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'

      - name: Check for secrets in code
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD

  database-migration:
    name: Database Migration
    runs-on: ubuntu-latest
    needs: [determine-environment, pre-deployment-checks]
    if: needs.determine-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install backend dependencies
        run: npm ci
        working-directory: ./backend

      - name: Run database migrations
        run: npm run migrate
        working-directory: ./backend
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NODE_ENV: ${{ needs.determine-environment.outputs.environment }}

      - name: Verify migration status
        run: npm run migrate:status
        working-directory: ./backend
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: [determine-environment, database-migration]
    if: needs.determine-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine image tag
        id: image_tag
        run: |
          if [[ "${{ github.event.inputs.version }}" != "" ]]; then
            echo "tag=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [[ "${{ needs.determine-environment.outputs.environment }}" == "production" ]]; then
            echo "tag=latest" >> $GITHUB_OUTPUT
          else
            echo "tag=develop" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to staging
        if: needs.determine-environment.outputs.environment == 'staging'
        run: |
          echo "Deploying backend to staging environment..."
          # Add staging deployment commands here
          # Example: kubectl, docker-compose, or cloud provider CLI
          
          # Update staging deployment
          cat <<EOF > backend-staging.yml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: omnisecai-backend-staging
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: omnisecai-backend-staging
            template:
              metadata:
                labels:
                  app: omnisecai-backend-staging
              spec:
                containers:
                - name: backend
                  image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-backend:${{ steps.image_tag.outputs.tag }}
                  ports:
                  - containerPort: 8000
                  env:
                  - name: NODE_ENV
                    value: "staging"
                  - name: DATABASE_URL
                    valueFrom:
                      secretKeyRef:
                        name: omnisecai-secrets
                        key: database-url
                  - name: REDIS_URL
                    valueFrom:
                      secretKeyRef:
                        name: omnisecai-secrets
                        key: redis-url
                  - name: JWT_SECRET
                    valueFrom:
                      secretKeyRef:
                        name: omnisecai-secrets
                        key: jwt-secret
          EOF
          
          # Apply deployment (uncomment when Kubernetes is set up)
          # kubectl apply -f backend-staging.yml

      - name: Deploy to production
        if: needs.determine-environment.outputs.environment == 'production'
        run: |
          echo "Deploying backend to production environment..."
          # Add production deployment commands here
          
          # Blue-Green deployment strategy for production
          cat <<EOF > backend-production.yml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: omnisecai-backend-production
          spec:
            replicas: 3
            strategy:
              type: RollingUpdate
              rollingUpdate:
                maxUnavailable: 1
                maxSurge: 1
            selector:
              matchLabels:
                app: omnisecai-backend-production
            template:
              metadata:
                labels:
                  app: omnisecai-backend-production
              spec:
                containers:
                - name: backend
                  image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_PREFIX }}-backend:${{ steps.image_tag.outputs.tag }}
                  ports:
                  - containerPort: 8000
                  env:
                  - name: NODE_ENV
                    value: "production"
                  - name: DATABASE_URL
                    valueFrom:
                      secretKeyRef:
                        name: omnisecai-secrets
                        key: database-url
                  - name: REDIS_URL
                    valueFrom:
                      secretKeyRef:
                        name: omnisecai-secrets
                        key: redis-url
                  - name: JWT_SECRET
                    valueFrom:
                      secretKeyRef:
                        name: omnisecai-secrets
                        key: jwt-secret
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 60
                    periodSeconds: 30
          EOF
          
          # Apply deployment (uncomment when Kubernetes is set up)
          # kubectl apply -f backend-production.yml

      - name: Wait for deployment to be ready
        run: |
          echo "Waiting for backend deployment to be ready..."
          # Add health check commands here
          sleep 30

  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-backend]
    if: needs.determine-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build
        env:
          VITE_API_URL: ${{ secrets.VITE_API_URL }}
          VITE_WS_URL: ${{ secrets.VITE_WS_URL }}
          VITE_ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}

      - name: Deploy to staging (Netlify/Vercel)
        if: needs.determine-environment.outputs.environment == 'staging'
        run: |
          echo "Deploying frontend to staging..."
          # Example: Deploy to Netlify
          # npx netlify-cli deploy --prod --dir=dist --site=${{ secrets.NETLIFY_SITE_ID_STAGING }}

      - name: Deploy to production (CDN)
        if: needs.determine-environment.outputs.environment == 'production'
        run: |
          echo "Deploying frontend to production..."
          # Example: Deploy to AWS S3 + CloudFront
          # aws s3 sync dist/ s3://${{ secrets.S3_BUCKET_PRODUCTION }} --delete
          # aws cloudfront create-invalidation --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} --paths "/*"

  post-deployment-tests:
    name: Post-deployment Tests
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-frontend]
    if: needs.determine-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run smoke tests
        run: npm run test:smoke
        env:
          TEST_BASE_URL: ${{ secrets.APP_URL }}
          API_BASE_URL: ${{ secrets.API_URL }}

      - name: Run API health checks
        run: |
          echo "Running API health checks..."
          curl -f ${{ secrets.API_URL }}/health || exit 1
          curl -f ${{ secrets.API_URL }}/health/detailed || exit 1

      - name: Run frontend health checks
        run: |
          echo "Running frontend health checks..."
          curl -f ${{ secrets.APP_URL }} || exit 1

  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    needs: [determine-environment, post-deployment-tests]
    if: failure() && needs.determine-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Rollback deployment
        run: |
          echo "Deployment failed, initiating rollback..."
          # Add rollback commands here
          # kubectl rollout undo deployment/omnisecai-backend-${{ needs.determine-environment.outputs.environment }}
          # kubectl rollout undo deployment/omnisecai-frontend-${{ needs.determine-environment.outputs.environment }}

  notify-deployment:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [determine-environment, post-deployment-tests]
    if: always() && needs.determine-environment.outputs.should_deploy == 'true'
    steps:
      - name: Send Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
          custom_payload: |
            {
              username: 'GitHub Actions',
              icon_emoji: ':rocket:',
              attachments: [{
                color: '${{ job.status }}' === 'success' ? 'good' : 'danger',
                blocks: [{
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: `*Deployment ${{ job.status }}* \n*Environment:* ${{ needs.determine-environment.outputs.environment }}\n*Repository:* ${process.env.AS_REPO}\n*Commit:* ${process.env.AS_COMMIT}\n*Author:* ${process.env.AS_AUTHOR}`
                  }
                }]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: env.SLACK_WEBHOOK_URL != ''

      - name: Create GitHub deployment status
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment?.id || 0,
              state: '${{ job.status }}' === 'success' ? 'success' : 'failure',
              environment: '${{ needs.determine-environment.outputs.environment }}',
              description: 'Deployment ${{ job.status }}'
            });

  update-documentation:
    name: Update Documentation
    runs-on: ubuntu-latest
    needs: [determine-environment, post-deployment-tests]
    if: success() && needs.determine-environment.outputs.environment == 'production'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Update deployment documentation
        run: |
          echo "Updating deployment documentation..."
          cat <<EOF >> DEPLOYMENT_LOG.md
          
          ## Deployment $(date)
          
          - **Environment**: Production
          - **Commit**: ${{ github.sha }}
          - **Author**: ${{ github.actor }}
          - **Branch**: ${{ github.ref_name }}
          - **Workflow**: ${{ github.run_id }}
          
          ### Changes
          $(git log --oneline -10)
          
          EOF

      - name: Commit documentation updates
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add DEPLOYMENT_LOG.md
          git commit -m "docs: Update deployment log for production release" || exit 0
          git push